module Day3p2 where

import           Data.Function   ((&))
import           Data.List       (nub)
import           Data.List.Split (chunksOf)
import           Data.Monoid     ((<>))

import           Test.Hspec      (hspec, it, shouldBe)

type Ring = [Int]
type Side = [Int]
type Level = Int

solution :: Int -> Int
solution n =
  head . head
  $ dropWhile null -- skip past empty rings
  $ map (dropWhile (<=n) . ring) [0..]

ring :: Level -> Ring
ring 1 = [1]
ring level = go (zip [0..] (contrib (level - 1))) []
  where
    go [] xs = reverse xs
    go (k:ks) xs =
      go ks (calc k xs : xs)
    calc (0, inner) _  = inner
    calc (n, inner) xs =
      let
        afterCorner  = n - 1 `elem` corners level
        isLastTwo    = n == size - 1 || n == size - 2
        maybeCorner  = if afterCorner then xs !! 1 else 0
        maybeLastTwo = if isLastTwo then last xs else 0
      in
      inner + head xs + maybeCorner + maybeLastTwo
    size = ringSize level

-- | Take the list of adjacent cells to each outer-ring-index returned by `adj`
--   and calculates their contribuation to the overall sum. Handles the
--   duplicates generated by `stretch`
contrib :: Int -> [Int]
contrib 1 = replicate 8 1
contrib level =
  [0 .. ringSize (level + 1) - 1]
  & map (adj (ring level))
  & map (sum . nub)

ringSize :: Level -> Int
ringSize level = (2*level-2)*4

-- | Get adjacent cells of the lower ring
--   For example, say the rightmost column is the outer ring 3,
--   then `adj (ring (3-1)) 1` = [25, 1, 2]
--
--    2|
--    1|54 -- offset 1 for outer ring
--   25|26 -- offset 0 for outer ring
--    |  └──── ring 3
--    └──── ring 2
--
-- Has special handling for the beginning and end of the ring (0 and `last
-- stretched` values) and special handling of corners via `stretch`
--
-- * The beginning of the outer ring will be adjacent to the last element of the
--   inner ring. Therefore it is prepended to the list.
-- * To make indexing into the list easier, prepend a 0.
-- * The fact that elements around the corner will be adjacent to duplicate
--   values will be handled by `contrib` (just filters duplicate out)

adj :: Ring -> Int -> [Int]
adj r offset = (\n -> xs !! (n+offset)) <$> [0, 1, 2]
  where xs = 0:last streched:streched
        streched = stretch r

-- | Stretches a ring by duplicating its corners twice, which helps make it
--   extend as much as its outer ring. Making the inner ring line up to the
--   outer ring in order to calculate adjacent cells
stretch :: Ring -> Ring
stretch [1]  = [1,1,1,1,1,1]
stretch r = concatMap extendSide $ sides r
  where extendSide xs = xs <> replicate 2 (last xs)

sides :: Ring -> [Side]
sides [x] = [[x]]
sides ns  = chunksOf (length ns `div` 4) ns

corners :: Int -> [Int]
corners level = take 4 $ iterate (+sideLength) (sideLength-1)
  where sideLength = ringSize level `div` 4


-- Tests

test :: IO ()
test = hspec $ do
  it "works for ring 2" $ do
    ring 2
    `shouldBe`
    [1, 2, 4, 5, 10, 11, 23, 25]

  it "works for ring 3" $ do
    ring 3
    `shouldBe`
    [26,54,57,59,122,133,142,147,304,330,351,362,747,806,880,931]

  it "works for ring 4" $ do
    take 18 (ring 4) -- couldn't be bothered calculating them all
    `shouldBe`
    [957, 1968, 2105, 2275, 2391, 2450, 5022, 5336, 5733, 6155, 6444, 6591, 13486, 14267, 15252, 16295, 17008, 17370]
